--! @file viterbi_top1.sql_in
--! System requirement: !PostgreSQL 8.4.1
--! @examp
--! Compute the ML segmentation for the first document
--!      select MADLIB_SCHEMA.vcrf_top1(1);
--!      select * from display_u10;
--!
--! Compute the ML segmentation for the first 10 documents
--!      truncate table u10;
--!      select MADLIB_SCHEMA.vcrf_top1(doc_id) from doc_id_tbl where doc_id<11;
--!      select * from display_u10;


---------------------------------------------------------------
-- UDF: normalization(int)
-- usage: compute normalization factor for a given document
-- input: doc_id
-- output: normalization factor
----------------------------------------------------------------

set search_path to enron;

-- drop function normalization(int);

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.normalization(int) RETURNS integer AS
$$
WITH U11 AS (WITH RECURSIVE V (start_pos, score) AS (
  SELECT st.start_pos, mr.score[1:((SELECT count(*) FROM labels)::int)] 
    FROM segmenttbl st, mrtbl mr 
   WHERE st.doc_id = $1 AND st.start_pos = 0 AND mr.seg_id = st.seg_id
  UNION ALL
  SELECT st.start_pos, MADLIB_SCHEMA.vcrf_sum_array(v.score, mr.score) 
    FROM segmenttbl st, V, mrtbl mr 
   WHERE st.doc_id = $1 AND st.start_pos = v.start_pos+1 
         AND mr.seg_id = st.seg_id
)
SELECT score FROM V WHERE start_pos = (SELECT MAX(start_pos) FROM V))
SELECT MADLIB_SCHEMA.vcrf_sum(score) FROM U11 AS return;
$$ LANGUAGE SQL STRICT;

--! \examp
--! select normalization(doc_id) from doc_id_tbl where doc_id=1;

---------------------------------------------------------------------
-- UDF: viterbi_top1(int)
-- usage: compute top1 labelings for a document
-- input: doc_id
-- output: null
-- side effect: insert into relation u10, containing top1 labelings
---------------------------------------------------------------------

--drop function viterbi_top1(int);

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.vcrf_top1(int) RETURNS void AS
$$
INSERT INTO U10 
WITH RECURSIVE L(start_pos,seg_id,score) AS 
  (SELECT * FROM (SELECT start_pos, seg_id, MADLIB_SCHEMA.vcrf_max_top1_array(score) 
                    FROM U11 
                ORDER BY  start_pos DESC 
                   LIMIT 1) K
   UNION ALL 
   SELECT U11.start_pos, U11.seg_id, 
          ARRAY[ [L.score[2][1]] ]  
          || ARRAY[ [U11.score[2][ L.score[2][1] + 1 ] ]] 
          || ARRAY [ [L.score[3][1]] ] 
     FROM U11, L 
    WHERE U11.start_pos = L.start_pos - 1
  ),
U11 AS 
  (WITH RECURSIVE V (start_pos, seg_id, score) AS 
    (SELECT st.start_pos, st.seg_id, 
            mr.score[1:((SELECT COUNT(*) FROM labels)::int)] 
            || ARRAY[array_fill(-1,ARRAY[((SELECT COUNT(*) FROM labels)::INT)]) ] 
       FROM segmenttbl st, mrtbl mr 
      WHERE st.doc_id = $1 AND st.start_pos = 0 AND mr.seg_id = st.seg_id
    UNION ALL
    SELECT st.start_pos, st.seg_id, MADLIB_SCHEMA.vcrf_topk_array(v.score, mr.score) 
      FROM segmenttbl st, V, mrtbl mr 
     WHERE st.doc_id = $1 AND st.start_pos = v.start_pos+1 
       AND mr.seg_id = st.seg_id
     )
   SELECT * FROM V)
SELECT $1 AS doc_id, start_pos, seg_id, score[1][1], score [3][1] from L;
$$ LANGUAGE SQL STRICT;

--Example:
--select MADLIB_SCHEMA.vcrf_top1(doc_id) from doc_id_tbl where doc_id=1;

